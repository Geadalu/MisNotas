\chapter{Metodología}
\label{cap:metodologia}

En este capítulo se explica la metodología de desarrollo que se ha seguido, describiendo desde la captura de requisitos hasta el producto final. Al final del capítulo se añade un apartado con el análisis de costes.

\section{Metodología de desarrollo}

Para organizar el proyecto y permitir un desarrollo eficaz e incremental se ha seguido una metodología de desarrollo en espiral: el \gls{pud}\cite{pud} y \cite{apuntes}.

\subsection{Características principales}
El \gls{pud} es una metodología de desarrollo que transforma los requisitos de usuario en un sistema software. Es muy genérica, y por eso se ha decidido adaptar a este proyecto.
Las características básicas del \gls{pud} son las siguientes:
\begin{itemize}
	\item \textbf{Dirigido por casos de uso:} en este proyecto, los usuarios, como se ha mencionado anteriormente, son el personal docente de \gls{eso}. Los casos de uso que se han contemplado para el proyecto son las acciones que se han especificado en el capítulo \ref{cap:Introduccion}. Se hablará de la metodología seguida para la captura de requisitos más adelante.
	\item \textbf{Centrado en la arquitectura:} una de las primeras fases del proyecto es realizar el esquema de la base de datos y la comprensión de la futura arquitectura del programa. Esto determinará el orden en el que se desarrollarán los casos de uso.
	\item \textbf{Iterativo e incremental:} se ha trabajado mediante iteraciones o \textit{sprints}, en las que cada una o bien añadía una nueva funcionalidad, mejoraba una de las ya existentes, o realizaba pruebas de cohesión entre los módulos recién añadidos y los que ya estaban desarrollados. También cabe notar que el método de iteraciones ha sido el de terminar por completo una parte, hasta las pruebas, antes de comenzar con otra nueva. En cada iteración en la que se añade una nueva funcionalidad, se siguen los siguientes pasos:
	\begin{enumerate}
		\item Se elige una de las que todavía no se han desarrollado.
		\item Dentro de la funcionalidad, se identifican y especifican los casos de uso que le corresponden.
		\item Se refinan los diseños que se hicieron al principio del proyecto para estos casos de uso.
		\item Se implementan y se prueban dentro del módulo de manera que satisfaga de manera vaga los requisitos.
	\end{enumerate}
	
	En cada iteración en la que se mejora una funcionalidad existente, los pasos son:
	\begin{enumerate}
		\item Se elige una de las funcionalidades a probar.
		\item Se prueba exhaustivamente dentro de su módulo para identificar los errores actuales y posibles futuros, y se arreglan los fallos.
	\end{enumerate}
	
	En cada iteración en la que se prueba la cohesión entre los módulos, el proceso seguido es:
	\begin{enumerate}
		\item Se elige uno de los módulos, preferentemente el último que se ha desarrollado.
		\item Se prueba con el resto de los módulos con los que mantiene cualquier tipo de comunicación, se identifican los errores y se arreglan los fallos.
	\end{enumerate}
	
	\item \textbf{Enfocado en los riesgos:} primero se han desarrollado los casos de uso más grandes que, después del primer diseño, se consideró que tendrían más impacto en el programa. Seguidamente, se fue trabajando desarrollando los distintos módulos, uno por cada funcionalidad y una iteración por funcionalidad.
	
\end{itemize}

\subsection{Etapas del proyecto}

Esta metodología implica la división del proyecto en cuatro etapas:
\begin{itemize}
    \item \textbf{Inicio:} para comenzar, se han recogido todos los requisitos y se ha estimado el alcance del proyecto. En esta etapa también se hizo la investigación de las aplicaciones ya existentes, descritas en el capítulo \ref{cap:aplicacionesexistentes} y el análisis de costes, desglosado en la sección \ref{sec:analisiscostes}.
    \item \textbf{Elaboración:} se hicieron prototipos de las interfaces, se diseñó el software mediante diagramas y se estimaron las iteraciones a seguir.
    \item \textbf{Construcción:} se escribió el software según el resultado de la fase de elaboración, siguiendo las iteraciones previamente calculadas. 
    \item \textbf{Transición:} para finalizar se probó el producto final y se dio fin al desarrollo.
\end{itemize}

\subsection{Obtención de requisitos}
\label{sub:obtencionrequisitos}

Para la obtención y clasificación de los requisitos, se ha optado por:
\begin{itemize}
	\item \textbf{Observación activa:} se estudiará el entorno de trabajo del usuario final. Para ello, se realizó una sesión en la que se monitorizó a un usuario usando una de las herramientas descritas en el capítulo Aplicaciones existentes, preguntándole sus opiniones sobre algunas de las características que estaba utilizando.
	\item \textbf{Realización de entrevistas} con el usuario en las que irá evaluando el producto final de cada \textit{sprint} o iteración y añadiendo o modificando características.
\end{itemize}

Además, se ha aplicado la regla \textit{MoSCoW} para priorizar el desarrollo de los requisitos funcionales. Esta regla divide los requisitos en cuatro categorías:
\begin{enumerate}
	\item \textbf{\textit{Must have} (M):} requisitos que la aplicación debe tener y son prioritarios a cualquier otro de menor rango.	
	\item \textbf{\textit{Should have} (S):} estos requisitos, de menor rango que los Must have, siguen siendo importantes para el desarrollo de la aplicación.	
	\item \textbf{\textit{Could have} (C):} requisitos de más baja prioridad, que pueden posponerse si hay otros de mayor rango por encima de ellos.	
	\item \textbf{\textit{Won't have} (W):} requisitos completamente opcionales que la aplicación podría llegar a tener de manera que mejorasen las funcionalidades.
	
\end{enumerate}



\section{Marco tecnológico de trabajo}

En esta sección se detallan las tecnologías usadas para el desarrollo de la aplicación.

\subsection{Java}
En la fase de Inicio del proyecto se estudió qué lenguaje de programación utilizar para su desarrollo. Al principio se propuso C\#, pero debido a las restricciones de horario de la desarrolladora y su previo conocimiento de Java (fuente: \cite{java}), se optó finalmente por el segundo.

Otra de las razones por las que se decantó por Java para realizar el proyecto fue la facilidad con la que se crean y modifican las interfaces gráficas con este lenguaje, concretamente si se usa un \gls{ide}.

A continuación se muestra una lista describiendo brevemente las librerías externas que se han usado en el desarrollo de este proyecto.
\begin{itemize}
	\item \textbf{Apache Poi}: permite crear y modificar archivos Microsoft Excel \cite{apachepoi}.
	\item \textbf{JFreeChart}: crea diagramas y gráficos y permite personalizarlos de varias maneras \cite{jfreechart}.
\end{itemize}

\subsection{Git y GitHub}
Se ha usado una herramienta de control de versiones llamada Git \cite{git}. Esta herramienta permite subir el código a un repositorio, elegir los cambios que se quieren subir y deshacer los que se han hecho en caso de error. Ha sido de gran ayuda para gestionar el código y las iteraciones correctamente.

Otra razón por la que se ha optado por Git es porque, desde su página web \url{www.github.com}, permite un control de \textit{Issues} o problemas. Esto se ha usado de manera constante para tener mejor control de los errores que iban saliendo en el programa tras las iteraciones de desarrollo.

Por último, cabe destacar que también se ha usado la herramienta "Releases", que permite realizar lanzamientos de la aplicación, de manera que los usuarios que visiten el repositorio identificarán rápidamente cuál es la versión que pueden instalarse y ejecutar.


\subsection{Balsamiq Wireframes}
\label{sub:balsamiq}
Para realizar en la fase de Elaboración las maquetas de las interfaces (ver figura \ref{Fig:mockup_mainwindow}), se ha usado la aplicación Balsamiq Wireframes \cite{balsamiq}. Esto permite modelar las interfaces de una manera fácil y sencilla. Permite hacer modelos de interfaces para ordenador, tablet y smartphone, y cuenta con una variedad de elementos que se pueden llamar entre sí para realizar una demo.

\subsection{Texmaker y Overleaf}
Se ha optado por los editores de textos Texmaker y Overleaf para escribir este documento. Texmaker es una apliación de escritorio, que permite escribir y compilar en \LaTeX{}, que es el sistema de composición de textos mediante el cual se ha creado esta memoria.

Texmaker cuenta con el paquete LatexMk, que automatiza la compilación de todas las partes del documento: texto, bibliografía y referencias, y genera el resultado final en un PDF.

Overleaf \cite{overleaf} es, a su vez, un editor de texto para \LaTeX{}, pero para navegador web. Se ha decidido usar este cuando se ha tenido que cambiar de sitio de trabajo.

\subsection{NetBeans IDE}
Para la escritura de todo el código se ha usado el \gls{ide} gratuito NetBeans.
Este \gls{ide} cuenta con una potente herramienta para realizar las interfaces de los programas en Java, además, es altamente personalizable y tiene conexión con Git al repositorio de GitHub, de tal manera que, en un vistazo, se pueden ver las clases que han cambiado respecto a la versión que hay en GitHub.


\subsection{Procreate}
\label{sub:procreate}
Para el diseño de los iconos e imágenes que se han creado, se ha usado la aplicación de dibujo profesional Procreate.

Es una aplicación sencilla e intuitiva que cuenta con varias herramientas para composición de dibujo y pintura.


\subsection{MySQL Workbench}
\label{sub:mysql}
Para la creación y gestión de la base de datos, se ha optado por MySQL Workbench (ver figura. Esta herramienta ha sido verdaderamente útil a la hora de gestionar todos los cambios que se han tenido que ir haciendo a medida que el proyecto iba creciendo, debido a la facilidad de uso y las funcionalidades que posee.


\subsection{Otras herramientas}
Cabe mencionar brevemente el uso de otras herramientas que han sido útiles en el desarrollo de este proyecto:
\begin{itemize}
	\item \textbf{tablesgenerator.com:} Como ayuda para la generación de tablas en este documento, se ha usado la herramienta web \url{https://www.tablesgenerator.com/}. Esta página permite crear una tabla de manera visual y generar el código \LaTeX{} correspondiente.
	\item \textbf{paint.net:} es un programa de escritorio para la edición de imágenes de manera básica. Se ha usado para cambiar el tamaño de las imágenes creadas con Procreate o de las sacadas de internet.
	\item \textbf{app.diagrams.net:} potente herramienta web usada para crear todos los diagramas de este documento.
\end{itemize}